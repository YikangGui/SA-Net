# README

## Notes
All data is generated based on the new MDP which is described in the following. 

Rather than retraining the SA-Net, I just merged the state `atHome` and `onConveyor` as `onConveyor`. 

For example, if the previous state is `[0.1, 0.2, 0.3, 0.4]` for `[atHome, onConveyor, inFront, atBin]`, the new state is 
`[0.3, 0.3, 0.4]` for `[onConveyor, inFront, atBin]`, in which I just simply add them up.

There are two states added to yolo state, which are `none` and `unknown`. 

Here it is the optimal policy for the new MDP.
```angular2html
OnConveyor, none    => Pick
OnConveyor, unknown => Pick*              
OnConveyor, good    => PlaceOnConveyor
OnConveyor, bad     => PlaceInBin
InFront   , none    => Pick
InFront   , unknown => Inspect
InFront   , good    => PlaceOnConveyor
InFront   , bad     => PlaceInBin
AtBin     , none    => Pick
AtBin     , unknown => Pick**
AtBin     , good    => PlaceOnConveyor
AtBin     , bad     => PlaceInBin

* Updated from the original discussion
** Added from the original discussion
```

## MDP

### State:
``` 
End effctor location:
    0. onConveyor
    1. inFront 
    2. atBin

Onion YOLO state:
    0. none
    1. unknown
    2. bad
    3. good
```
### Action:
```
End effector action:
    0. Pick
    1. Inspect
    2. PlaceOnConveyor
    3. PlaceOnBin
```

### Transition:
The interval is 10 frames which is 1/3 second.

Saved in `transition_new_dist.npy`. To open the file, please use numpy package with command:

`np.load(PATH_TO_FILE, allow_pickle=True).item()`

Then you will get a **dictionary**. The structure of the dictionary is in the following:
```
dictionary:
--- state and action 1 (eef, yolo, action):
    |--- next state 1 (eef, yolo): probability
    |--- next state 2 (eef, yolo): probability
    |--- next state 3 (eef, yolo): probability
    |...
    
--- state and action 2 (eef, yolo, action):
    |--- next state 1 (eef, yolo): probability
    |--- next state 2 (eef, yolo): probability
    |--- next state 3 (eef, yolo): probability
    |...
    
--- ...
```

#### Example
``` 
''' We want the transition probability of 
        state: (onConveyor, unknown), 
        action: Pick, 
        next state: (inFront, unknown)
'''
>>> transition = np.load(PATH_TO_FILE, allow_pickle=True).item()
>>> transition.get(('onConveyor', 'unknown', 'Pick'), {}).get(('inFront', 'unknown'), 0.0)
>>> transition_prob
0.2741228070175439
```

`transition_new_dist.csv` is a visualization of the transition function. You can check some transitions easily by opening this file.

If some transitions don't exist in this file, then it means those transitions have 0 probability. The file only lists 
possible transitions in the MDP. 

### Updated
**Therefore, use `get()` to retrieve the transition probabilities from the dictionary and set the default value showed in the example.**

I also attach the original counts for the transition function in file `transition_new.npy` and `transition_new.csv`. In that file, you can see that
there are many transitions that have very few counts. For now, I don't filter them and, I keep them in the transition function. To improve the performance,
we may eliminate those transitions that have few counts.


## Trajectory



The trajectories are saved in `19_trajectory.npy` and `20_trajectory.npy`. To load the trajectory, please run the following command:

`np.load(PATH_TO_FILE, allow_pickle=True).item()`

Then you will get a **dictionary**. The structure of the dictionary is in the following:
```
dictionary:
--- time duration 0:
    |--- 'eef': distribution
    |--- 'yolo': distribution
    |--- 'action': accurate action

--- time duration 1:
    |--- 'eef': distribution
    |--- 'yolo': distribution
    |--- 'action': accurate action

--- ...
```
#### Example
``` 
''' We want the state and action at time duration 5:
        state: (eef, yolo)
        action: action
'''
>>> trajectory = np.load(PATH_TO_FILE, allow_pickle=True).item()
>>> time_5 = trajectory[5]
>>> time_5
{'eef': array([0., 1., 0.], dtype=float16), 'yolo': array([0., 1., 0., 0.]), 'action': 'Inspect'}
>>> time_5['eef']  # get eef location
array([0., 1., 0.], dtype=float16)
>>> time_5['yolo']  # get yolo prediction
array([0., 1., 0., 0.])
>>> time_5['action']  # get action
'Inspect'
```

`19_trajectory.csv` and `20_trajectory.csv` are visualizations of the transition function. You can check some trajectories easily by opening this file.

### Updated 
The trajectory is generated with the interval = 10 frames which is identical to the generation of transition function. 

All states are generated by the average of 10 frames and all actions are generated by taking the majority of 10 frames.